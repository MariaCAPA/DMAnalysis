/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "RooDMPdf.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

#include "DMPhysConstants.hh"
#include "DMRate.hh"

ClassImp(RooDMPdf) 

RooDMPdf::RooDMPdf(const char *name, const char *title, 
                        RooAbsReal& _energy,
                        RooAbsReal& _sSI,
                        RooAbsReal& _mW) :
   RooAbsPdf(name,title), 
   energy("energy","energy",this,_energy),
    sSI(" sSI"," sSI",this,_sSI),
    mW(" mW"," mW",this,_mW),
    fDMRate(0),tIni(0),tEnd(0)
{ 
} 


 RooDMPdf::RooDMPdf(const RooDMPdf& other, const char* name) :  
   RooAbsPdf(other,name), energy("energy",this,other.energy),
   sSI(" sSI",this,other.sSI), mW(" mW",this,other.mW),tIni(other.tIni),
   tEnd(other.tEnd)
{ 
  fDMRate = new DMRate(*other.fDMRate);
} 

 RooDMPdf::~RooDMPdf()
{
  if (fDMRate) delete fDMRate;
}


int RooDMPdf::initialize(const char * fileRate)
{
  if (fDMRate) delete fDMRate;

  fDMRate = new DMRate();
  fDMRate->Initialize((char * )fileRate);

  fDMRate->SetMW(mW);
  fDMRate->SetSigSI(sSI);
}

 Double_t RooDMPdf::evaluate() const 
 { 

   DMRate theRate (*fDMRate);

   theRate.SetMW(mW);
   theRate.SetSigSI(sSI);

   double S0, Sm, Phi;

   int err = theRate.Rate(energy, &S0, &Sm, &Phi);

   double retval = S0;
   double Phi_d = Phi*365; // Phi is in years


   // Integrate modulated part only if time interval is provided
   if (tEnd>tIni)
   {
     // Integral of Sm * cos(DAYTORAD*(time - Phi_d));
     double integ = Sm*(sin(DAYTORAD*(tEnd-Phi_d)) - sin(DAYTORAD*(tIni-Phi_d)))/DAYTORAD/(tEnd-tIni); // Divide by Delta_time because result is in c/keV/kg/d (as for S0).  The return value will be multiplied by exposure externally

     retval += integ;
   }

   return retval;
 } 
